# forgetmenot

General Data Protection Regulation ([GDPR](https://gdpr-info.eu/art-17-gdpr/)) states that users have *"the right to be forgotten"*. Blockchain will have none of this :fu:. This repo serves as a practical example of why you have to think twice when putting data on the blockchain. I will later expand on this idea to show how this property of blockchain could be leveraged to reduce transaction costs in smart-contracts.

## requirements to run this :sob:
* A browser with [metamask](https://metamask.io/) (Chrome, Firefox, Opera or Brave)
* NodeJS
* Truffle (`npm install -g truffle`)

## building and deploying to contract
1. Install the dependencies to run demo 
	>`npm install`

2. Open a console with a local development blockchain
	>`truffle develop`
	
	The address we will be using is: **0x627306090abab3a6e1400e9345bc60c78a8bef57**
	and the private key: **c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3**. I'm not sure if these addresses and private keys are hardcoded into truffle, so yours could differ.

3. Deploy the smart contract by the following commands in the *truffle development console*. The out hashes will not match these outputs.
	> **truffle(develop)>** `compile`  
	> Compiling .\contracts\Forgetmenot.sol...  
	> Compiling .\contracts\Migrations.sol...  
	> Writing artifacts to .\build\contracts  
	>  
	> **truffle(develop)>** `migrate`  
	> Using network 'develop'.  
	>   
	> Running migration: 1_initial_migration.js  
	>   Deploying Migrations...  
	>   ... 0x4f55d85f9b2e2e3149d70ab4848e713e796f0744f6606b7051e423f4903e5838  
	>   Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0  
	> Saving successful migration to network...  
	>   ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956  
	> Saving artifacts...  
	> Running migration: 2_forgetmenot.js  
	>   Deploying Forgetmenot...  
	>   ... 0xdcf2271f20f8bc32295f399154d7853e410173a920bad6d232e38918a3ffd644  
	>   Forgetmenot: 0x345ca3e014aaf5dca488057592ee47305d9b3e10  
	> Saving successful migration to network...  
	>   ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0  
	> Saving artifacts...  

4. Open another console window and start the web server. It should open a browser window, but if does not, navigate to [localhost:3000](http://localhost:3000)
	> `npm run dev`

## setup metamask

To interact with the contract on store data on the blockchain, you will an Ethereum account and some ether to burn. We will be using the local accounts for this purpose.

1. **Add a custom RPC**. Since we will be running a development blockkchain, we need to point metamask to our local blockchain's RPC address.

	![metamask custom rpc](./README/metamask_custom_rpc.png?raw=true)

2. **Add a develop account with ether**. The truffle dev account comes preloaded with a few accounts you can use for testing. Use any of the *private keys* generated by `truffle develop`.

	![metamask new account](./README/metamask_new_account.png?raw=true)
	

## test drive
When you open the web page, you should see a **super slick** :laughing: page with a box to add a key and a value.
![forgetmenot fresh](./README/forgetmenot_fresh.png?raw=true)

You will note some info about the account you are using.
* **web3 available** : web3 gets injected by Metamask, if this is *false* nothing will work.
* **coinbase** : this is the address of this account generated from the private key. This should match one of the `truffle development` accounts. If you switch accounts in Metamask, just refresh the page (F5)
* **balance**: this should be ~100 ether. If this is 0, switch to an account with some ether in.
 
As you start adding new they will be listed to the right of the input card.
![forgetmenot](./README/forgetmenot.png?raw=true)

When adding a new entry a Metamask popup will appear and ask you to confirm this transaction. Sometimes the popup does not appear, but a badge appears on the Metatmask icon to indicate a pending transaction.

![forgetmenot](./README/metamask_pending.png?raw=true)

## :unamused: what is happening here?
If you have a look at the *smart-contract* you will notice tow things. Firstly an event only stores a single key, value and two numbers. Secondly, only **1 / one / uno / een** of these are stored per account (address).

```
mapping (address => Entry) private addressToEntryMapping;
```

Every time you add a new entry, you override the old value. This is not entirely true, you are updating the current state of contract which will be included in the next block, but the "overrided" value was included in a previous block, which is immutable. SO we simply need to know where the change ocurred to fetch historic values. The `linkToPreviousBlock` variable is what helps us to go lookup the previous value.

```
function createEntry (string _key, string _value) public {

 Entry storage entry = addressToEntryMapping[msg.sender];
 entry.linkToPreviousBlock = entry.createdBlock;
 entry.createdBlock = block.number;

 entry.key = _key;
 entry.value = _value;
} 
```

:hand: You might think that this would not be possible with the link to the block in which the previous change ocurred, but this is not the case. The link simplifies the process, without it the code would simply have to to check block by block for changes to build the history. This would be painful, but not impossible.

## :cool: related links
* A bit more interesting way to read storage in Ethereum: https://medium.com/aigang-network/how-to-read-ethereum-contract-storage-44252c8af925
* The right to be forgotten: https://gdpr-info.eu/art-17-gdpr/

